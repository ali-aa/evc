Абдель Маджид Али
Поиск собственных значений для симметричных матриц QR алгоритмом в варианте "метода
вращений", приведение к трехдиагональному виду унитарным подобием методом вращений.

Описание интерфейса программы
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Для работы с программой используются следующие ключи:
-d 				  печать отладочных сообщений
-e 				  печать ошибок
-p 				  печать матрицы
-t 				  печать времени выполнения
-prec=<num>       пороговое значение, меньше которого считать равным число 0
-eps=<num>        необходимая точность
-max_iter=<num>   маскимальное число итераций
-h 				  справка


Справка при работе с программой:

Usage: evc [input_file_name] [output_file_name] [options]
Where options include:
  -d    print debug messages [default OFF]
  -e    print errors [default OFF]
  -p    print matrix [default OFF]
  -t    print execution time [default OFF]
  -prec=<num>       precision [default - 1e-14] 
  -eps=<num>        'epsilon' [default - 1e-10]
  -max_iter=<num>   limit number of iterations
                    [default - 0, i.e. not limit]
  -h, -?     print this and exit

Программа возвращает следующие коды ошибок после выполнения:

EXIT -1		  	 неверные параметры командной строки
ERR_MEM -2	  	 возникла ошибка при выделении памяти
ERR_FILE -3	   	возникла ошибка при открытии/создании файла или при чтении/записи в файл
ERR_FILE_FORMAT -4 неверный формат входного файла
OK 0		   выполнение завершено без ошибок

Реализованы следующие вспомогательные функции:
~~~~~~~~~~~~~~~~~~~~~
#define addr(i, j) ((i)*n+j)
	макрос для пересчета координат из двухмерных в одномерные


Модуль упрощения sim_01_14.c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

int is_symmetric(int n, double *A)
Проверка на симметричность
Вход: размер матрицы A, матрица A 

void comp_phi(double *A, double *cos_phi, double *sin_phi, int n, int i, int j)
Вычисляются cos phi и sin phi, которые отвечают матрице вращения Tij
Вход: матрица A, адрес куда поместится cos phi, адрес куда поместится sin phi, размерность мтарицы, первый индекс матрицы вращения, второй индекс матрицы вращения

void left_mult_T_v(double *A, int k, double cos_phi, double sin_phi, int i, int j, int n)
Вход: матрица A, текущий вектор столбец, значение cos для соотвествующей матрицы вращения, значение sin для соотвествующей матрицы вращения, первый индекс матрицы вращений, второй индекс матрицы вращений, размерность матрицы A

void left_mult_T_A(double *A, int n, double cos_phi, double sin_phi, int i, int j)
Вход: матрица A, размерность матрицы A, значение cos для соотвествующей матрицы вращения, значение sin для соотвествующей матрицы вращения, первый индекс матрицы вращений Tij, второй индекс матрицы вращений Tij

void right_mult_T_v(double *A, int k, double cos_phi, double sin_phi, int i, int j, int n)
Вход: матрица A, текущий столбец, значение cos для соотвествующей матрицы вращения, значение sin для соотвествующей матрицы вращения, первый индекс матрицы вращений, второй индекс матрицы вращений, размерность матрицы A

void right_mult_T_A(double *A, int n, double cos_phi, double sin_phi, int i, int j)
Вход: матрица A, размерность матрицы A, значение cos для соотвествующей матрицы вращения, значение sin для соотвествующей матрицы вращения, первый индекс матрицы вращений Tij, второй индекс матрицы вращений Tij

Вычислительный модуль evc_01_14.c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

double norm(double *A, int n)
Норма матрица A (норма бесконечность)
Вход: матрица A, размерность матрицы A
Выход: значение нормы матрицы A

void add_shift(double *A, double s_k, int n, int cur_n)
Добавление сдвига по диагонали матрицы A
Вход: матрица A, величниа сдвига, размерность матрицы, текущая размерность матрицы

void sub_shift(double *A, double s_k, int n, int cur_n)
Вычитание сдвига по диагонали матрицы A
Вход: матрица A, величниа сдвига, размерность матрицы, текущая размерность матрицы

void comp(double *A, double *cos_phi, double *sin_phi, int n, int i, int j)
Вычисляются cos phi и sin phi, которые отвечают матрице вращения Tij
Вход: матрица A, адрес куда поместится cos phi, адрес куда поместится sin phi, размерность мтарицы, первый индекс матрицы вращения Tij, второй индекс матрицы вращения Tij

void left_mul_T_v(double *A, int k, double cos_phi, double sin_phi, int i, int j, int n)
Умножение вектора на матрицу вращения Tij слева
Вход: матрица A, текущий столбец, значение cos для соотвествующей матрицы вращения, значение sin для соотвествующей матрицы вращения, первый индекс матрицы вращений Tij, второй индекс матрицы вращений Tij, размерность матрицы A

void left_mul_T_A(double *A, int n, int cur_n, double cos_phi, double sin_phi, int i, int j)
Умножение матрицы A на матрицу вращения Tij слева
Вход: матрица A, размерность матрицы A, текущая размерность матрицы A, значение cos для соотвествующей матрицы вращения, значение sin для соотвествующей матрицы вращения, первый индекс матрицы вращений Tij, второй индекс матрицы вращений Tij

void right_mul_T_v(double *A, int k, double cos_phi, double sin_phi, int i, int j, int n)
Умножение вектора на матрицу вращения Tij справа
Вход: матрица A, текущий столбец, значение cos для соотвествующей матрицы вращения, значение sin для соотвествующей матрицы вращения, первый индекс матрицы вращений Tij, второй индекс матрицы вращений Tij, размерность матрицы A

void right_mul_T_A(double *A, int n, int cur_n, double cos_phi, double sin_phi, int i, int j)
Умножение матрицы A на матрицу вращения Tij справа
Вход: матрица A, размерность матрицы A, текущая размерность матрицы A, значение cos для соотвествующей матрицы вращения, значение sin для соотвествующей матрицы вращения, первый индекс матрицы вращений Tij, второй индекс матрицы вращений Tij

Интерфейсный модуль main_01_14.c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void free_res(double *A, double *E, double *tmp, FILE *fin, FILE *fout)
Освобождает выделененные ресурсы
Вход: матрица A, вектор собственных значений E, временный массив tmp, файл входных данных, файл выходных данных

void print_matrix(int n, double *A)
Вывод матрицы
Вход: размерность матрицы, матрица A

void print_eig_val(int n, double *E)
Вывод вектора собственных значений матрицы
Вход: Размерность векора, вектор собственных значений E

int parse_cmdline(int argc, char **argv, int *in_file, int *out_file, char *out_mode, char *stat_mode, int *max_iter, double *eps, double *prec)
Разбор параметров командной строки
Вход: количество аргументов командной строки, аргументы командной строки, флаг входного файла, флаг выходного файла, флаг вывода, флаг статистики, максимальное количество итераций, необходимая точность, величнина, значение меньше которой считать равным 0
Выход: в случае не успеха возвращается EXIT

Описание алгоритма приведения симметричной матрицы к трехдиагональному виду методом вращения
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Сначала осуществляется проверка на симметричноcть

Шаг итерации k, начиная с 2:
Вычисляются cos phi и sin phi, которые будут отвечать последовательности
матриц для преобразования исходной матрицы A
Для конретной матрицы вращения Tij их значения ищутся по формулам: cos phi = xi / sqrt(xi*xi + xj * xj), sin phi = -xj / sqrt(xi*xi + xj * xj)
(Tij* есть транcпонированная матрица к Tij)
Осуществляется умножение слева на матрицы вращения Tij
A = Tkn...Tk,k+1A
Осуществляется умножение справа на матрицы вращения Tij
A = ATk,k+1*...Tkn*

На выходе получается трехдиаганальная матрица

Описание QR алгоритма в варианте "вращения" вычисления собвенных значений для трехдиаганальной матрицы
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Считается норма матрицы

QR алгоритм:
Шаг итерации k, начиная с 1:

A1 = A
Если шаг кратен 101, то определеяем сдвиг как s_k = A[cur_n-1, cur_n-1] и вычитаем его из диаганали матрицы A:
	Ak = Ak - s_kI

Производим QR разложение:
	Ak = QkRk
	Для построения Rk применяется метод вращений, матрица A умножается слева на последователность из матриц Tij:
	Rk = Tkn...Tk,k+1A
	Qk представляет из себя 2 вектора в которых хранится cos phi_i_i+1 и sin phi_i_i+1 соотвественно
	Ak+1 = RkQk
Если шаг кратен 101, то Ak+1 = Ak+1 + s_kI

Если |A[cur_n-1, cur_n-2]| < eps * normA, то в качестве следующего собственного
значения выбирается A[cur_n-1, cur_n-1] и размер матрицы уменьшается на 1.

Продолжается пока размер матрицы не уменьшится до 2x2.
Её собственные значения вычисляются как корни квадртаного уравнения.

Затем собственные значения сортируются. В данном случае простым алгоритмом сортировки пузырьком, но он не портит асимптотики алгоритма,
поэтому является примелимым.

Добавление сдвигов позволило увеличить скорость сходимости и увеличить класс матрицы
пригодных для данного QR алгоритма.

